An overview of some key concepts related to this test suite:

# mTLS
[mTLS explained](https://www.cloudflare.com/learning/access-management/what-is-mutual-tls/)

[mTLS in Envoy](https://www.envoyproxy.io/docs/envoy/latest/start/quick-start/securing#use-mutual-tls-mtls-to-enforce-client-certificate-authentication)

# Gloo mTLS
[Background](https://docs.solo.io/gloo-edge/latest/guides/security/tls/mtls/)

In Gloo Edge, services that receive their configuration from the xDS server, communicate using the xDS protocol, which is done in plaintext. Since the information being provided contains sensitive information (secrets), it is preferable to encrypt this traffic. This applies to the following services:
- Gateway-proxy
- Ext-auth-service
- Rate-limiter

## How does this work?
Each component involved in the xDS communication will contain an SDS sidecar and potentially an Envoy sidecar as well (for our gateway-proxy pod, which already contains an envoy container, this Envoy sidecar is not necessary)

**Envoy Sidecar**: Responsible for TLS termination, and outgoing encryption. Receives it’s secret information via SDS, talking to the SDS sidecar. The sidecar bootstrap configuration is defined in a ConfigMap for each component.

**SDS Sidecar**: Watches the gloo-mtls-certs TLS secret in kubernetes, and serves the contents via the SDS API to the Envoy sidecar. The SDS code can be found [here](https://github.com/solo-io/gloo/tree/main/projects/sds). Anytime the secret is modified, the contents will be updated dynamically. To automate the updating of secrets, run the [CertGen Job](https://github.com/solo-io/gloo/blob/main/install/helm/gloo/templates/19-gloo-mtls-certgen-job.yaml)


### Example: Gloo <-> ExtAuth
[ExtAuth Envoy Sidecar](https://github.com/solo-io/solo-projects/blob/main/install/helm/gloo-ee/templates/24-extauth-sidecar-config.yaml)

- ExtAuth pod initiates xDS request to Gloo
- ExtAuth.EnvoySidecar hijacks request, and sends encrypted request to Gloo
- Gloo.EnvoySidecar terminates TLS request from ExtAuth
- Gloo.EnvoySidecar directs request to Gloo xDS port

# Istio mTLS

[Background](https://docs.solo.io/gloo-edge/latest/guides/integrations/service_mesh/istio/)

When services are deployed within the Istio Service Mesh, it is possible to require that all traffic between those services is encrypted with mTLS. This is handled dynamically by Istio managing certs for services within the Mesh. However, it poses a challenge when Gloo Edge (not in the Mesh) tries to route traffic to services within the Mesh.

This challenge is that Edge encrypts traffic using the certificates that were generated by IstioD and used within the Mesh.  To accomplish this, Edge uses a similar paradigm as the Gloo mTLS solution, leveraging sidecars to encrypt traffic.

## How does this work?
To keep the mTLS communication transparent to the Edge configuration, we again leverage sidecars to handle the encryption.

[Istio](https://istio.io/latest/docs/ops/deployment/architecture/) is logically split into a data plane and a control plane. The data plane is composed of a set of intelligent proxies (Envoy) deployed as sidecars. The control plane (istiod) provides service discovery, configuration and certificate management.
Istiod acts as a Certificate Authority (CA) and generates certificates to allow secure mTLS communication in the data plane.

**Istio-Proxy Sidecar**: This is responsible for generating the certificates used for mTLS communication. These certificates are mounted to a volume, which are then provided to the gateway-proxy configuration via SDS. The gateway-proxy, with these certificates, is now able to establish mTLS communication with an upstream in the Mesh. 
The Istio-Proxy Sidecar usually runs both the istio-agent and envoy. The [istio-agent](https://github.com/istio/istio/blob/master/architecture/security/istio-agent.md) is responsible for generating the certificates, and the envoy is responsible for terminating TLS and establishing mTLS communication with other services in the Mesh. 
By default, the istio-proxy will run an extended version of the Envoy proxy. However, we don't need the istio-proxy Envoy functionality, we only need the istio-agent to create the CSR request to istiod and handle rotating certificates near expiration. 
To avoid running the istio-proxy Envoy, we can set the `DISABLE_ENVOY` environment variable. This will cause the istio-proxy to run in proxyless mode and not start the Envoy process. 

<img src="https://github.com/istio/istio/raw/master/architecture/security/docs/overview.svg">

**SDS Sidecar**: Watches the Istio certs, generated by the istio-proxy sidecar, and serves them up via SDS to the gateway-proxy. The SDS code can be found [here](https://github.com/solo-io/gloo/tree/main/projects/sds). Any time the volume is modified, the contents will be updated dynamically. This is done because Istio rotates its certificates by default, every 24 hours (can be controlled by env variable). Without this SDS sidecar, the proxies would use outdated certificates, and when new ones are rolled out by Istio, our gateway-proxy wouldn’t be able to communicate with services using the new certificates.

# SDS

Envoy provides an API for dynamically updating TLS certificates. Historically, this required restarting the proxies with the new certificates, but the [SDS API](https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret) allows a zero-downtime approach to this.

In Gloo Edge, we build an SDS server which implements this API. Its sole responsibility is to implement the SDS API, and serve up certificates via xDS. We configure our Envoy proxies as the client to this server, and the proxies are [configured to get their certificates via the SDS API](https://github.com/solo-io/gloo/blob/main/install/helm/gloo/templates/9-gateway-proxy-configmap.yaml#L195)

While the component itself has a single responsibility, implement the SDS API, it can be used in Gloo Edge in multiple ways:
- Serve certificates to establish mTLS communication between Gloo components (Gloo mTLS)
- Serve certificates to establish mLTS communication between Gateway-Proxy and Application running in Service Mesh (Istio mTLS)

_As a result, we have `glooMtls.enabled` to enable the former, and `istioSDS.enabled` to enable the latter._

Note, the current Gloo SDS does not reach out to Istiod. The istio-agent is responsible for sending the CSR to Istiod. 
The SDS server then reads the certs from a file written by the istio-agent and then SDS serves the certificates to the Gloo Envoy proxy.

# Validating mTLS Traffic

Istio leverages the [`x-forwarded-client-cert`](https://istio.io/latest/docs/ops/configuration/traffic-management/network-topologies/#forwarding-external-client-attributes-ip-address-certificate-info-to-destination-workloads) header to identify encrypted traffic

If the application that we’re running can logs requests that it receives, we could search the logs for the existence of that header

# Additional context
Additional context on Istio and how the Gloo integration with Istio works can be found [here](https://docs.google.com/document/d/1g7wq6yBGR6VioNJTz_eA7GLRbijlDasGR3h-eToz7jA)