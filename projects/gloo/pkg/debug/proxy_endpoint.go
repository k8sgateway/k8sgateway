package debug

import (
	"context"

	"github.com/rotisserie/eris"

	"github.com/solo-io/go-utils/contextutils"

	"github.com/solo-io/gloo/projects/gloo/pkg/api/grpc/debug"
	v1 "github.com/solo-io/gloo/projects/gloo/pkg/api/v1"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
	"google.golang.org/grpc"
)

// ProxySource represents the type of translator that produced the Proxy resource
type ProxySource int

const (
	EdgeGatewayTranslation ProxySource = iota // Proxies that are generated by the Edge Gateway controller
	K8sGatewayTranslation                     // Proxies that are generated by the K8s Gateway controller
)

var (
	proxySourceByName = map[string]ProxySource{
		"edge-gw": EdgeGatewayTranslation,
		"k8s-gw":  K8sGatewayTranslation,
	}
)

// Open Questions:
// 1. Should users have to specify which type of Proxy they want, or should they just ask, and we return
// any proxies that fit that criteria (so we look at all available proxies)

// ProxyEndpointServer responds to requests for Proxies, and returns them
// The server relies on ProxyReaders being registered with the server
type ProxyEndpointServer interface {
	debug.ProxyEndpointServiceServer

	Register(grpcServer *grpc.Server)
	RegisterProxyReader(source ProxySource, client ProxyReader)
}

// ProxyReader exposes the subset of methods from a v1.ProxyClient that are read-only
type ProxyReader interface {
	Read(namespace, name string, opts clients.ReadOpts) (*v1.Proxy, error)
	List(namespace string, opts clients.ListOpts) (v1.ProxyList, error)
}

type proxyEndpointServer struct {
	// readersBySource contains the set of ProxyReaders that have been registered for the server
	readersBySource map[ProxySource]ProxyReader
}

// NewProxyEndpointServer returns an implementation of the ProxyEndpointServer
func NewProxyEndpointServer() ProxyEndpointServer {
	return &proxyEndpointServer{
		readersBySource: make(map[ProxySource]ProxyReader, 1),
	}
}

func (p *proxyEndpointServer) Register(grpcServer *grpc.Server) {
	debug.RegisterProxyEndpointServiceServer(grpcServer, p)
}

func (p *proxyEndpointServer) RegisterProxyReader(source ProxySource, proxyReader ProxyReader) {
	p.readersBySource[source] = proxyReader
}

// GetProxies receives a request from outside the gloo pod and returns a filtered list of proxies in a format that mirrors the k8s client
func (p *proxyEndpointServer) GetProxies(ctx context.Context, req *debug.ProxyEndpointRequest) (*debug.ProxyEndpointResponse, error) {
	contextutils.LoggerFrom(ctx).Infof("received grpc request to read proxies")
	proxyReader, err := p.getProxyReaderForRequest(req)
	if err != nil {
		return nil, err
	}

	if req.GetName() != "" {
		proxy, readErr := proxyReader.Read(req.GetNamespace(), req.GetName(), clients.ReadOpts{Ctx: ctx})
		return &debug.ProxyEndpointResponse{
			Proxies: v1.ProxyList{proxy},
		}, readErr
	}

	proxyList, listErr := proxyReader.List(req.GetNamespace(), clients.ListOpts{
		Ctx:      ctx,
		Selector: req.GetSelector(),
	})
	return &debug.ProxyEndpointResponse{
		Proxies: proxyList,
	}, listErr
}

func (p *proxyEndpointServer) getProxyReaderForRequest(req *debug.ProxyEndpointRequest) (ProxyReader, error) {
	// If the request does not contain a source, we fall back to the standard Edge Gateway translator
	proxySource := EdgeGatewayTranslation
	if req.GetSource() != "" {
		requestProxySource, ok := proxySourceByName[req.GetSource()]
		if !ok {
			return nil, eris.Errorf("ProxyEndpointRequest.source (%s) is not a valid option. Available options are: %v", req.GetSource(), proxySourceByName)
		}
		proxySource = requestProxySource
	}

	proxyReader, ok := p.readersBySource[proxySource]
	if !ok {
		// This should not really occur. If this does, it likely means that a developer forgot to write the code
		// to register a given proxySource with the ProxyEndpointServer
		return nil, eris.Errorf("ProxyEndpointRequest.source (%s) does not have a registered reader", req.GetSource())
	}

	return proxyReader, nil
}
