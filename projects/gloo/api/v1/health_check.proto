syntax = "proto3";
package gloo.solo.io;
option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1";

import "validate/validate.proto";
import "gogoproto/gogo.proto";
import "google/protobuf/wrappers.proto";
import "google/protobuf/duration.proto";

option (gogoproto.equal_all) = true;

/*
    Envoy cluster health check configuration

    See [envoy docs](https://www.envoyproxy.io/docs/envoy/v1.11.0/intro/arch_overview/upstream/health_checking#arch-overview-health-checking) for more information on how health checks work in envoy
    Or examine the [config definition](https://www.envoyproxy.io/docs/envoy/v1.11.0/api-v2/api/v2/core/health_check.proto#envoy-api-msg-core-healthcheck).
*/
message HealthCheckConfig {

    google.protobuf.Duration timeout = 1 [(gogoproto.stdduration) = true];

    google.protobuf.Duration interval = 2 [(gogoproto.stdduration) = true];

    // The number of unhealthy health checks required before a host is marked
    // unhealthy. Note that for *http* health checking if a host responds with 503
    // this threshold is ignored and the host is considered unhealthy immediately.
    google.protobuf.UInt32Value unhealthy_threshold = 4;

    // The number of healthy health checks required before a host is marked
    // healthy. Note that during startup, only a single successful health check is
    // required to mark a host healthy.
    google.protobuf.UInt32Value healthy_threshold = 5;

    message HttpHealthCheck {
        // The value of the host header in the HTTP health check request. If
        // left empty (default value), the name of the cluster this health check is associated
        // with will be used.
        string host = 1;

        // Specifies the HTTP path that will be requested during health checking. For example
        // */healthcheck*.
        string path = 2 [(validate.rules).string.min_bytes = 1];

        // An optional service name parameter which is used to validate the identity of
        // the health checked cluster. See the :ref:`architecture overview
        // <arch_overview_health_checking_identity>` for more information.
        string service_name = 5;

        // If set, health checks will be made using http/2.
        bool use_http2 = 7;
    }

    // `grpc.health.v1.Health
    // <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
    // healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
    // for details.
    message GrpcHealthCheck {
        // An optional service name parameter which will be sent to gRPC service in
        // `grpc.health.v1.HealthCheckRequest
        // <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
        // message. See `gRPC health-checking overview
        // <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
        string service_name = 1;

        // The value of the :authority header in the gRPC health check request. If
        // left empty (default value), the name of the cluster this health check is associated
        // with will be used.
        string authority = 2;
    }

    oneof health_checker {
        option (validate.required) = true;

        // HTTP health check.
        HttpHealthCheck http_health_check = 8;

        // gRPC health check.
        GrpcHealthCheck grpc_health_check = 11;
    }
}

/*
    Envoy cluster health check configuration

    See [envoy docs](https://www.envoyproxy.io/docs/envoy/v1.11.0/intro/arch_overview/upstream/outlier#arch-overview-outlier-detection) for more information on how health checks work in envoy
    Or examine the [config definition](https://github.com/envoyproxy/envoy/blob/v1.11.0/api/envoy/api/v2/cluster/outlier_detection.proto#L22).
*/
message OutlierDetection {
    // The number of consecutive 5xx responses or local origin errors that are mapped
    // to 5xx error codes before a consecutive 5xx ejection
    // occurs. Defaults to 5.
    google.protobuf.UInt32Value consecutive_5xx = 1;

    // The time interval between ejection analysis sweeps. This can result in
    // both new ejections as well as hosts being returned to service. Defaults
    // to 10000ms or 10s.
    google.protobuf.Duration interval = 2 [(validate.rules).duration.gt = {}];

    // The base time that a host is ejected for. The real time is equal to the
    // base time multiplied by the number of times the host has been ejected.
    // Defaults to 30000ms or 30s.
    google.protobuf.Duration base_ejection_time = 3 [(validate.rules).duration.gt = {}];

    // The maximum % of an upstream cluster that can be ejected due to outlier
    // detection. Defaults to 10% but will eject at least one host regardless of the value.
    google.protobuf.UInt32Value max_ejection_percent = 4 [(validate.rules).uint32.lte = 100];

    // The % chance that a host will be actually ejected when an outlier status
    // is detected through consecutive 5xx. This setting can be used to disable
    // ejection or to ramp it up slowly. Defaults to 100.
    google.protobuf.UInt32Value enforcing_consecutive_5xx = 5 [(validate.rules).uint32.lte = 100];

    // The % chance that a host will be actually ejected when an outlier status
    // is detected through success rate statistics. This setting can be used to
    // disable ejection or to ramp it up slowly. Defaults to 100.
    google.protobuf.UInt32Value enforcing_success_rate = 6 [(validate.rules).uint32.lte = 100];

    // The number of hosts in a cluster that must have enough request volume to
    // detect success rate outliers. If the number of hosts is less than this
    // setting, outlier detection via success rate statistics is not performed
    // for any host in the cluster. Defaults to 5.
    google.protobuf.UInt32Value success_rate_minimum_hosts = 7;

    // The minimum number of total requests that must be collected in one
    // interval (as defined by the interval duration above) to include this host
    // in success rate based outlier detection. If the volume is lower than this
    // setting, outlier detection via success rate statistics is not performed
    // for that host. Defaults to 100.
    google.protobuf.UInt32Value success_rate_request_volume = 8;

    // This factor is used to determine the ejection threshold for success rate
    // outlier ejection. The ejection threshold is the difference between the
    // mean success rate, and the product of this factor and the standard
    // deviation of the mean success rate: mean - (stdev *
    // success_rate_stdev_factor). This factor is divided by a thousand to get a
    // double. That is, if the desired factor is 1.9, the runtime value should
    // be 1900. Defaults to 1900.
    google.protobuf.UInt32Value success_rate_stdev_factor = 9;

    // The number of consecutive gateway failures (502, 503, 504 status codes)
    // before a consecutive gateway failure ejection occurs. Defaults to 5.
    google.protobuf.UInt32Value consecutive_gateway_failure = 10;

    // The % chance that a host will be actually ejected when an outlier status
    // is detected through consecutive gateway failures. This setting can be
    // used to disable ejection or to ramp it up slowly. Defaults to 0.
    google.protobuf.UInt32Value enforcing_consecutive_gateway_failure = 11
    [(validate.rules).uint32.lte = 100];

    // Determines whether to distinguish local origin failures from external errors. If set to true
    // the following configuration parameters are taken into account:
    // :ref:`consecutive_local_origin_failure<envoy_api_field_cluster.OutlierDetection.consecutive_local_origin_failure>`,
    // :ref:`enforcing_consecutive_local_origin_failure<envoy_api_field_cluster.OutlierDetection.enforcing_consecutive_local_origin_failure>`
    // and
    // :ref:`enforcing_local_origin_success_rate<envoy_api_field_cluster.OutlierDetection.enforcing_local_origin_success_rate>`.
    // Defaults to false.
    bool split_external_local_origin_errors = 12;

    // The number of consecutive locally originated failures before ejection
    // occurs. Defaults to 5. Parameter takes effect only when
    // :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
    // is set to true.
    google.protobuf.UInt32Value consecutive_local_origin_failure = 13;

    // The % chance that a host will be actually ejected when an outlier status
    // is detected through consecutive locally originated failures. This setting can be
    // used to disable ejection or to ramp it up slowly. Defaults to 100.
    // Parameter takes effect only when
    // :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
    // is set to true.
    google.protobuf.UInt32Value enforcing_consecutive_local_origin_failure = 14
    [(validate.rules).uint32.lte = 100];

    // The % chance that a host will be actually ejected when an outlier status
    // is detected through success rate statistics for locally originated errors.
    // This setting can be used to disable ejection or to ramp it up slowly. Defaults to 100.
    // Parameter takes effect only when
    // :ref:`split_external_local_origin_errors<envoy_api_field_cluster.OutlierDetection.split_external_local_origin_errors>`
    // is set to true.
    google.protobuf.UInt32Value enforcing_local_origin_success_rate = 15
    [(validate.rules).uint32.lte = 100];
}
