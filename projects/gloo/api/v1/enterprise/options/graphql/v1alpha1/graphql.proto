syntax = "proto3";

package enterprise.gloo.solo.io;

option go_package = "github.com/solo-io/gloo/projects/gloo/pkg/api/v1/enterprise/options/graphql/v1alpha1";

option java_package = "io.envoyproxy.envoy.config.filter.http.graphql.v2";
option java_outer_classname = "GraphQLFilterProto";
option java_multiple_files = true;

import "extproto/ext.proto";
option (extproto.equal_all) = true;
option (extproto.hash_all) = true;

import "github.com/solo-io/solo-kit/api/v1/metadata.proto";
import "github.com/solo-io/solo-kit/api/v1/status.proto";
import "github.com/solo-io/solo-kit/api/v1/solo-kit.proto";

import "validate/validate.proto";

import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/core/v3/http_uri.proto";
import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/core/v3/extension.proto";
import "github.com/solo-io/gloo/projects/gloo/api/external/envoy/config/core/v3/base.proto";
import "google/protobuf/empty.proto";

// Ideas for Resolvers, these are NOT IMPLEMENTED yet:

// used to reference into json structures by key(s)
// TODO(kdorosh): implement me
message PathSegment {
  oneof segment {
    option (validate.required) = true;
    string key = 1 [(validate.rules).string = {min_len: 1}];
    uint32 index = 2;
  }
}

// TODO(kdorosh): do we want to support regex and subgroups?
// TODO(kdorosh): implement me
message ValueProvider {

  message GraphQLArgExtraction {
    // The argument name to fetch. The argument value fetched
    // will have a type from the schema that we validate in envoy.
    // If the name is invalid, returns the zero-value primitive or null.
    string arg_name = 1;
    // Optional: fetches the value in the argument selected at this key.
    // If the key is invalid, returns the zero-value primitive or null.
    repeated PathSegment path = 2;
  }

  message TypedValueProvider {
    message GraphQLParentExtraction {
      // Fetches the value in the graphql parent at this key. The value will
      // always be accepted since the parent object is not strongly-typed.
      // If the key is invalid, returns null.
      repeated PathSegment path = 1;
    }
    // if empty, defaults to string. similar to typeUrl in other envoy config
    enum Type {
      STRING = 0;
      INT = 1;
      FLOAT = 2;
      BOOLEAN = 3;
    }
    // Type that the value will be coerced into.
    // For example if the extracted value is "9", and type is INT,
    // this value will be cast to an int type.
    Type type = 1;
    oneof val_provider {
      // Fetch value from the graphql_parent of the current field.
      // todo(sai) - figure out behaviour when no parent (root query / mutation)
      GraphQLParentExtraction graphql_parent = 2;
      // Fetches the request/response header's value. If not found, uses empty string
      string header = 3;
      // inline value, use as provided rather than extracting from another source
      string value = 4;
    }
  }

  oneof provider {
    // type inferred from schema, no need to provide it.
    GraphQLArgExtraction graphql_arg = 1;
    TypedValueProvider typed_provider = 2;
  }
}

message JsonKeyValue {
  message JsonValue {
    oneof json_val {
      JsonNode node = 1;
      ValueProvider value_provider = 2;
    }
  }
  // if empty, the value will be parsed as json and replace the entire
  // previously-parsed json value
  string key = 1;
  JsonValue value = 2;
}

// Represents a typed JSON structure
// TODO(kdorosh): implement me
message JsonNode {
  // if keys repeat, the latest one replaces any earlier values associated
  // with that key.
  //
  // repeated list, rather than a map, to have ordering to allow for merge
  // semantics within the data plane, for example:
  // - gRPC input uses special empty string for input key to set entire body
  // - gRPC wants to replace a certain field in parsed body from GraphQL arg
  repeated JsonKeyValue key_values = 1;
}

// Defines a configuration for generating outgoing requests for a resolver.
// TODO(kdorosh): implement me
message RequestTemplate {
  // Use this attribute to set request headers to your REST service. It consists of a
  // map of strings to value providers. The string key determines the name of the
  // resulting header, the value provided will be the value.
  //
  // at least need ":method" and ":path"
  map<string, ValueProvider> headers = 1;

  // Use this attribute to set query parameters to your REST service. It consists of a
  // map of strings to value providers. The string key determines the name of the
  // query param, the provided value will be the value. This value is appended to any
  // value set to the :path header in `headers`.
  //
  // Interpolation is done in envoy rather than the control plane to prevent escaped
  // character issues.
  map<string, ValueProvider> query_params = 2;

  // implementation specific, gRPC will want gRPC message and struct to instantiate
  oneof outgoing_body {
    // json representation of outgoing body.
    // empty string key can be used to signal parsing the value as json and using it
    // as the whole json body.
    JsonNode json = 3;

    // Apply a template to the body
    // TODO(kdorosh): do we want in first iteration? Can easily be invalid json,
    // e.g. unescaped " (we can solve for this in control plane?)
    //InjaTemplate body = 3;
  }
}

// Defines a response transformation template.
// TODO(kdorosh): implement me (steal most logic from transformations code)
message ResponseTemplate {
  // TODO(kdorosh): in a follow up
  // modify json as it came back before execution. we're not sure what the
  // use cases here might be, hence doing in a follow up.
  //
  // Theoretical use cases:
  // - snake to camel case
  // - renaming fields (why?) aliasing is handled in graphql execution.cc

  // // Upserts the fields by key name.
  // map<string, JsonNode> fields = 1;
}

// data-plane API
// TODO(kdorosh): implement me
message RESTResolver {
  .solo.io.envoy.config.core.v3.HttpUri server_uri = 1;
  // configuration used to compose the outgoing request to a REST API
  RequestTemplate request_transform = 2;
  // pre-execution engine transformations
  //
  // Request flow: GraphQL request -> request_transform (instantiate REST request) ->
  // REST API resp -> pre_execution_transform -> execution engine ->
  // complete GraphQL field response
  //
  // TODO(kdorosh): revist in follow up
  //ResponseTemplate pre_execution_transform = 3;
  string span_name = 4;
}

// control-plane API
// TODO(kdorosh): implement me
message RESTResolverCP {

  message OpenApi {

    message RemoteSource {
      oneof remote_src {
        string remote_file = 1;
        string url_endpoint = 2;
      }
      // set headers for the HTTP request to fetch your openapi schema.
      map<string, string> schema_headers = 3;
    }

    // always parsed as yaml
    oneof source {
      string inline = 1; // for local testing only, since this otherwise not "discovered"

      // TODO(kdorosh): implement me
      //RemoteSource remote = 2;

      // TODO(kdorosh): implement me
      // string local_file = 3;

      // TODO(kdorosh):
      // consider envoy.config.core.v3.DataSource but this does not support remote files
    }

    // Use this attribute to set request headers to your REST service.
    // ":method" and ":path" will result in errors, as all permutations
    // of supported method/paths will be discovered as part of the OAS.
    map<string, string> headers = 2;

    // Specifies the URL on which all paths will be based on.
    // Overrides the server object in the OAS.
    string base_url = 3;

    // query search parameters to add to the API calls.
    map<string, string> query_params = 4;

    // TODO(kdorosh): allow regex?
    message SelectQueryOrMutationField {
      // OAS title
      string title = 1;
      string path = 2;
      string method = 3;
    }

    // By default, GET requests become GraphQL queries and POST requests become mutations.
    // By selecting certain endpoints, you can flip this default for those endpoints.
    repeated SelectQueryOrMutationField selections = 5;
  }

  oneof discovered_schema {
    // TODO(kdorosh): finish openapi api
    OpenApi openapi = 1;
    // TODO(kdorosh): json schema api?
  }
}

// TODO(yuval): implement a resolver for schema stiching
message SubgraphResolver {
  string cluster = 1;
}

// a resolver that can return a result that is a constant function of its arguments.
// TODO(kdorosh) do we even want to implement this (so far leaning no)
message ConstantResolver {
  // TODO(kdorosh): what was the idea here?
  //InjaTemplate result = 1;
}

// Resolve an abstract type (union or interface) to a real type.
// When implemented, this message will be a field in the Resolution message.
message AbstractTypeResolver {
  // TODO: add me
}


// When we'll support prepared queries, this will be the type containing the query.
message Query {
  .solo.io.envoy.config.core.v3.DataSource query = 1;
}

///////// END OF NOT IMPLMENTED CODE

message QueryMatcher {
  message FieldMatcher {
    // Object type. For example, Query.
    string type = 1;
    // Field with in the object.
    string field = 2;
  }

  oneof match {
    FieldMatcher field_matcher = 1;
  }
}

// This is the resolver map for the schema.
// For each Type.Field, we can define a resolver.
// if a field does not have resolver, the default resolver will be used.
// the default resolver takes the field with the same name from the parent, and uses that value
// to resolve the field.
// if a field with the same name does not exist in the parent, null will be used.
message Resolution {
  // Match an object type and field
  QueryMatcher matcher = 1;
  // The resolver to use.
  oneof resolver {
    google.protobuf.Empty default_resolver = 2;
    RESTResolver rest_resolver = 3;
  }
}
// Filter Listener config. Empty as the filter must be configured on the route level.
message GraphQLConfig {

}

// Filter Route config. Routes that have this config will execute graphql queries, and will not
// make it to the router filter. i.e. this filter will terminate the request for these routes.
message GraphQLExtendedSchema {

  option (core.solo.io.resource).short_name = "gqlschema";
  option (core.solo.io.resource).plural_name = "graphql_schemas";

  // Schema to use in string format.
  string schema = 1;
  // Do we enable introspection for the schema? general recommendation is to disable this for production
  // and hence it defaults ot false.
  bool enable_introspection = 2;
  // The resolver map to use to resovle the schema.
  repeated Resolution resolutions = 3;
  // In the future, we will support persistent queries, this will be a map of query id to query.
  //    map<string, Query> presistent_queries = 3;
  // when we support persistent queries, we may want to use them exclusivly, for predictable
  // operations. (i.e. no surprise mega query from a client).
  // bool only_persistent_queries = 4;

  // key is either:
  // Type
  // or
  // Type.Field where the latter takes precedence.
  // ??consider  Type and Type.Field **MUST** be in the schema ??
  // missing resolvers will yield error in the response
}